<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <h1 id="title" style="display: none;">ALGORITHMIST`24</h1>
    <div id="algorithms-container"></div>
    <script src="script.js"></script>
    
    <h2 style="text-align: center;">LIST OF ALGORITHMS</h2>
   

    <div class="algorithm-container">
        <div id="intro-container">
            <img id="college-logo" src="GFG .png" alt="College Logo">
            <div id="intro-text">
                <span id="are">Are</span>
                <span id="you">You</span>
                <span id="ready">Ready</span>
            </div>
        </div>
    
       
        <div id="algorithms-container"></div>
        <script src="script.js"></script>   

    <ol>
        <li>
            <strong>Longest common subsequence:</strong> This algorithm finds the longest subsequence that is common to two strings. It is used in many applications, such as text comparison and DNA sequence analysis.
            <ul>
                <li><a href="https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/">GeeksforGeeks</a></li>
                <li><a href="https://www.javatpoint.com/longest-common-subsequence">JavaTpoint</a></li>
                <li><a href="https://www.youtube.com/watch?v=sSno9rV8Rhg">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=NPZn9jBrX8U">YouTube Video 2</a></li>
            </ul>
        </li>
        
        <li>
            <strong>Edit distance:</strong> Given two strings str1 and str2 of length M and N respectively and below operations that can be performed on str1. Find the minimum number of edits (operations) to convert ‘str1‘ into ‘str2‘. It is used in many applications, such as text comparison and spell checking.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=fJaKO8FbDdo">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=We3YDTzNXEk">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/edit-distance-dp-5/">GeeksforGeeks</a></li>
            </ul>
        </li>
        <li>
            <strong>Longest common prefix:</strong> The longest common prefix for an array of strings is the common prefix between 2 most dissimilar strings. For example, in the given array {“apple”, “ape”, “zebra”}, there is no common prefix because the 2 most dissimilar strings of the array “ape” and “zebra” do not share any starting characters.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=VTr3Nh7BadI">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=wtOQaovlvhY">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/longest-common-prefix-using-sorting/">GeeksforGeeks</a></li>
                <li><a href="https://www.javatpoint.com/longest-common-prefix-in-python">JavaTpoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Sequence Alignment:</strong> Algorithms that align two or more sequences in order to find similarities and differences between them. The Needleman-Wunsch algorithm is a dynamic programming algorithm that finds the global alignment of two sequences. It works by building a matrix of all possible alignments of the two sequences, and then choosing the alignment with the highest score.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=of3B02hZGS0&ab_channel=FarhanHaq">YouTube Video 1</a></li>
                <li><a href="https://www.geeksforgeeks.org/sequence-alignment-problem/">GeeksforGeeks</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">Wikipedia</a></li>
            </ul>
        </li>
        <li>
            <strong>Z algorithm:</strong> This algorithm finds all occurrences of a pattern in a text in linear time. Let length of text be n and of pattern be m, then total time taken is O(m + n) with linear space complexity. Now we can see that both time and space complexity is same as KMP algorithm but this algorithm is simpler to understand.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=CpZh4eF8QBw">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=-1qq3hekxBw">YouTube Video 2</a></li>
                <li><a href="https://www.scaler.com/topics/data-structures/z-algorithm/">Scaler</a></li>
                <li><a href="https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/">GeeksforGeeks</a></li>
            </ul>
        </li>

       
        <li>
                <strong>Knapsack problem:</strong> The Knapsack problem is an example of the combinatorial optimization problem. This problem is also commonly known as the “Rucksack Problem''. The name of the problem is defined from the maximization problem as mentioned below:<br>
                Example: Given a bag with maximum weight capacity of W and a set of items, each having a weight and a value associated with it. Decide the number of each item to take in a collection such that the total weight is less than the capacity and the total value is maximized.
                <ul>
                    <li><a href="https://www.geeksforgeeks.org/introduction-to-knapsack-problem-its-types-and-how-to-solve-them/">GeeksforGeeks</a></li>
                </ul>
                <ol>
                    <li>
                        <strong>Fractional Knapsack Problem:</strong> Given the weights and profits of N items, in the form of {profit, weight} put these items in a knapsack of capacity W to get the maximum total profit in the knapsack. In Fractional Knapsack, we can break items for maximizing the total value of the knapsack.
                        <ul>
                            <li><a href="https://www.geeksforgeeks.org/fractional-knapsack-problem/">GeeksforGeeks</a></li>
                            <li><a href="https://www.javatpoint.com/fractional-knapsack-problem">JavaTpoint</a></li>
                            <li><a href="https://www.youtube.com/watch?v=xZfmHVi7FMg">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=2i5pclQprGk">YouTube Video 2</a></li>
                        </ul>
                    </li>
                    <li>
                        <strong>0/1 Knapsack Problem:</strong> We are given N items where each item has some weight (wi) and value (vi) associated with it. We are also given a bag with capacity W. The target is to put the items into the bag such that the sum of values associated with them is the maximum possible. Note that here we can either put an item completely into the bag or cannot put it at all.
                        <ul>
                            <li><a href="https://www.youtube.com/watch?v=nLmhmB6NzcM&t=5s">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=GqOmJHQZivw&t=3s">YouTube Video 2</a></li>
                            <li><a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/">GeeksforGeeks</a></li>
                            <li><a href="https://www.javatpoint.com/0-1-knapsack-problem">JavaTpoint</a></li>
                        </ul>
                    </li>
                </ol>
            </li>
            <li>
                <strong>Rod cutting:</strong> This algorithm finds the optimal way to cut a rod of length n into smaller rods, such that the total profit is maximized. It is a classic dynamic programming problem that has many applications in inventory management and manufacturing.
                <ul>
                    <li><a href="https://www.youtube.com/watch?v=mO8XpGoJwuo">YouTube Video 1</a></li>
                    <li><a href="https://www.youtube.com/watch?v=KvAsKDtEiPk">YouTube Video 2</a></li>
                    <li><a href="https://www.geeksforgeeks.org/cutting-a-rod-dp-13/">GeeksforGeeks</a></li>
                    <li><a href="https://sites.radford.edu/~nokie/classes/360/dp-rod-cutting.html">Radford University</a></li>
                </ul>
            </li>
            <li>
                <strong>Bin packing:</strong> Given n items of different weights and bins each of capacity c, assign each item to a bin such that number of total used bins is minimized. It may be assumed that all items have weights smaller than bin capacity.
                <ul>
                    <li><a href="https://www.youtube.com/watch?v=qbuMPi44bVQ">YouTube Video 1</a></li>
                    <li><a href="https://www.youtube.com/watch?v=kiMFyTWqLhc">YouTube Video 2</a></li>
                    <li><a href="https://www.geeksforgeeks.org/bin-packing-problem-minimize-number-of-used-bins/">GeeksforGeeks</a></li>
                    <li><a href="https://www.tutorialspoint.com/bin-packing-problem-minimize-number-of-used-bins-in-cplusplus">TutorialsPoint</a></li>
                </ul>
            </li>
            <li>
                <strong>Subset sum:</strong> Given a set of non-negative integers and a value sum, the task is to check if there is a subset of the given set whose sum is equal to the given sum.
                <ul>
                    <li><a href="https://www.youtube.com/watch?v=rYkfBRtMJr8">YouTube Video 1</a></li>
                    <li><a href="https://www.youtube.com/watch?v=7win3dcgo3k&t=303s">YouTube Video 2</a></li>
                    <li><a href="https://www.youtube.com/watch?v=kyLxTdsT8ws">YouTube Video 3</a></li>
                    <li><a href="https://www.geeksforgeeks.org/subset-sum-problem-dp-25/">GeeksforGeeks</a></li>
                </ul>
            </li>
            <li>
                <strong>Minimum coin change problem:</strong> This algorithm finds the minimum number of coins needed to make a given amount of change. It is a classic dynamic programming problem that has many applications in finance and economics.
                <ul>
                    <li><a href="https://www.youtube.com/watch?v=J2eoCvk59Rc">YouTube Video 1</a></li>
                    <li><a href="https://www.youtube.com/watch?v=myPeWb3Y68A">YouTube Video 2</a></li>
                    <li><a href="https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/">GeeksforGeeks</a></li>
                </ul>
            </li>
        
            
                <li>
                    <strong>Word wrap:</strong> Given a sequence of words, and a limit on the number of characters that can be put in one line (line width). Put line breaks in the given sequence such that the lines are printed neatly. Assume that the length of each word is smaller than the line width. Word processors like MS Word do the task of placing line breaks. The idea is to have balanced lines. In other words, do not have a few lines with lots of extra space and some lines with a small amount of extra space.
                    <ul>
                        <li><a href="https://www.youtube.com/watch?v=FVWAEzHSbRo">YouTube Video 1</a></li>
                        <li><a href="https://www.youtube.com/watch?v=th4OnoGasMU">YouTube Video 2</a></li>
                        <li><a href="https://www.geeksforgeeks.org/word-wrap-problem-dp-19/">GeeksforGeeks</a></li>
                        <li><a href="https://youtu.be/aPdpJ_RjaXs?si=QMvZ-6AsEFnb9UCC">YouTube Video 3</a></li>
                    </ul>
                </li>
                <li>
                    <strong>Traveling salesman problem (TSP):</strong> This algorithm finds the shortest tour that visits each city in a set of cities exactly once. It is a classic NP-hard problem that has many applications in transportation and logistics.
                    <ul>
                        <li><a href="https://www.youtube.com/watch?v=XaXsJJh-Q5Y">YouTube Video 1</a></li>
                        <li><a href="https://www.interviewbit.com/blog/travelling-salesman-problem/">InterviewBit Blog</a></li>
                        <li><a href="https://youtu.be/3QiSyc7KyC4?si=78XeEmL4SkNcCEWf">YouTube Video 2</a></li>
                        <li><a href="https://youtu.be/hh-uFQ-MGfw?si=ACtwV4Nn-yBibfzK">YouTube Video 3</a></li>
                        <li><a href="https://www.geeksforgeeks.org/travelling-salesman-problem-using-dynamic-programming/">GeeksforGeeks</a></li>
                    </ul>
                </li>
                <li>
                    <strong>Ford-Fulkerson algorithm:</strong> The max flow problem is a classic optimization problem in graph theory that involves finding the maximum amount of flow that can be sent through a network of pipes, channels, or other pathways, subject to capacity constraints. The Ford-Fulkerson algorithm is a greedy algorithm for computing the maximum flow in a flow network. The problem can be used to model a wide variety of real-world situations, such as transportation systems, communication networks, and resource allocation.
                    <ul>
                        <li><a href="https://www.youtube.com/watch?v=LdOnanfc5TM">YouTube Video 1</a></li>
                        <li><a href="https://www.youtube.com/watch?v=NwenwITjMys">YouTube Video 2</a></li>
                        <li><a href="https://www.geeksforgeeks.org/max-flow-problem-introduction/">GeeksforGeeks</a></li>
                        <li><a href="https://youtu.be/Iwc3Uj4aaF4?si=OhpafrNm1YNmmBxg">YouTube Video 3</a></li>
                    </ul>
                </li>
                <li>
                    <strong>Edmonds-Karp algorithm:</strong> The Edmonds-Karp algorithm is an efficient implementation of the Ford-Fulkerson method for finding the maximum flow in a flow network. It is primarily used to solve the maximum flow problem, which is a fundamental problem in network flow theory.
                    <ul>
                        <li><a href="https://youtu.be/asDetbDcmJw?si=ZBfHGuwQRJ1dx41F">YouTube Video 1</a></li>
                        <li><a href="https://www.youtube.com/watch?v=RppuJYwlcI8">YouTube Video 2</a></li>
                        <li><a href="https://www.youtube.com/watch?v=MczX0SM3I84">YouTube Video 3</a></li>
                        <li><a href="https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/">GeeksforGeeks</a></li>
                    </ul>
                </li>
                <li>
                    <strong>Optimal binary search tree (OBST):</strong> This algorithm constructs a binary search tree for a given set of keys, such that the expected search time is minimized. It is used in many applications, such as database systems and search engines.
                    <ul>
                        <li><a href="https://www.youtube.com/watch?v=vLS-zRCHo-Y">YouTube Video 1</a></li>
                        <li><a href="https://www.youtube.com/watch?v=8C7K6m_h-Og">YouTube Video 2</a></li>
                        <li><a href="https://www.geeksforgeeks.org/optimal-binary-search-tree-dp-24/">GeeksforGeeks</a></li>
                        <li><a href="https://www.javatpoint.com/optimal-binary-search-tree">JavaTpoint</a></li>
                    </ul>
                </li>

                
                    <li>
                        <strong>Maximum subarray sum:</strong> This algorithm finds the maximum sum of a contiguous subarray of an array. It is used in many applications, such as finding the maximum profit in a stock market chart or the minimum cost of a path between two nodes in a graph.
                        <ul>
                            <li><a href="https://www.youtube.com/watch?v=AHZpyENo7k4&t=1086s">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=Qd_qhRsSays">YouTube Video 2</a></li>
                            <li><a href="https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/">GeeksforGeeks</a></li>
                            <li><a href="https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/">TakeUForward</a></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Palindrome partitioning:</strong> This algorithm finds the minimum number of partitions needed to divide a string into palindromes. It is used in many applications, such as text processing and natural language processing.
                        <ul>
                            <li><a href="https://www.youtube.com/watch?v=WBgsABoClE0">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=Oi6a4O00n4U">YouTube Video 2</a></li>
                            <li><a href="https://www.geeksforgeeks.org/palindrome-partitioning-dp-17/">GeeksforGeeks</a></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Assembly line scheduling:</strong> Assembly line scheduling is a problem in operations management that involves determining the optimal sequence of tasks or operations on an assembly line to minimize production costs or maximize efficiency. This problem can be solved using various data structures and algorithms. One common approach is dynamic programming, which involves breaking the problem down into smaller sub-problems and solving them recursively.
                        <ul>
                            <li><a href="https://www.youtube.com/watch?v=EqGpcClPkkw">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=NODQhmJyMYE">YouTube Video 2</a></li>
                            <li><a href="https://www.geeksforgeeks.org/assembly-line-scheduling-dp-34/">GeeksforGeeks</a></li>
                            <li><a href="https://www.javatpoint.com/assembly-line-scheduling">JavaTpoint</a></li>
                        </ul>
                    </li>
                    <li>
                        <strong>A* Search Algorithm:</strong> The A* search algorithm is a graph search algorithm that finds the shortest path between a start node and a goal node. It is a heuristic algorithm, which means that it uses a heuristic function to guide its search. The heuristic function estimates the cost of moving from a node to the goal node. The A* search algorithm works by iteratively expanding the nodes in the graph that are closest to the goal node, based on the heuristic function.
                        <ul>
                            <li><a href="https://youtu.be/tvAh0JZF2YE?si=BAsOGlpUhW0d86Ef">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=PzEWHH2v3TE">YouTube Video 2</a></li>
                            <li><a href="https://www.youtube.com/watch?v=vP5TkF0xJgI">YouTube Video 3</a></li>
                            <li><a href="https://www.geeksforgeeks.org/a-search-algorithm/">GeeksforGeeks</a></li>
                        </ul>
                    </li>
                    <li>
                        <strong>Longest path in a directed acyclic graph:</strong> Given a directed graph G with N vertices and M edges. The task is to find the length of the longest directed path in Graph. Note: Length of a directed path is the number of edges in it.
                        <ul>
                            <li><a href="https://www.youtube.com/watch?v=YxF-x3imVFA">YouTube Video 1</a></li>
                            <li><a href="https://www.youtube.com/watch?v=jdTnoCBSOVM">YouTube Video 2</a></li>
                            <li><a href="https://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/">GeeksforGeeks</a></li>
                        </ul>
                    </li>
                
                   
                        <li>
                            <strong>Dijkstra's algorithm:</strong> Dijkstra's algorithm is a graph algorithm that finds the shortest path between a single source node and all other nodes in the graph. It is a greedy algorithm, meaning that it makes the locally optimal choice at each step in the hope of finding the globally optimal solution.
                            <ul>
                                <li><a href="https://www.youtube.com/watch?v=XB4MIexjvY0&t=641s">YouTube Video 1</a></li>
                                <li><a href="https://www.youtube.com/watch?v=V6H1qAeB-l4">YouTube Video 2</a></li>
                                <li><a href="https://www.javatpoint.com/dijkstras-algorithm">JavaTpoint</a></li>
                                <li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">GeeksforGeeks</a></li>
                            </ul>
                        </li>
                        <li>
                            <strong>Bellman-Ford algorithm:</strong> The Bellman-Ford algorithm is a similar algorithm to Dijkstra's algorithm, but it can handle graphs with negative edge weights. It works by repeatedly relaxing edges in the graph, which means that it updates the distances of nodes based on the shortest known path to them.
                            <ul>
                                <li><a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/">GeeksforGeeks</a></li>
                                <li><a href="https://www.javatpoint.com/bellman-ford-algorithm">JavaTpoint</a></li>
                                <li><a href="https://youtu.be/FtN3BYH2Zes?si=OdRNjZEW1Psd2-vH">YouTube Video 1</a></li>
                                <li><a href="https://youtu.be/KudAWAMiQog?si=OUzoC7ruVx6mvpMB">YouTube Video 2</a></li>
                                <li><a href="https://youtu.be/SiI03wnREt4?si=seb0CUQpjNGXohxK">YouTube Video 3</a></li>
                                <li><a href="https://youtu.be/0vVofAhAYjc?si=qeb6KVJ_4KRglSBR">YouTube Video 4</a></li>
                            </ul>
                        </li>
                        <li>
                            <strong>Prim's algorithm:</strong> Prim's algorithm is a greedy algorithm that finds a minimum spanning tree (MST) for a weighted undirected graph. An MST is a subset of the edges of the graph that connects all of the vertices in the graph with a minimal total weight.
                            <ul>
                                <li><a href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/">GeeksforGeeks</a></li>
                                <li><a href="https://www.gatevidyalay.com/prims-algorithm-prim-algorithm-example/">GateVidyalay</a></li>
                                <li><a href="https://youtu.be/mJcZjjKzeqk?si=WwSK8LAYl-bO7ceu">YouTube Video 1</a></li>
                                <li><a href="https://youtu.be/_KX8GDvRzBc?si=lu2mdXudjJROW_qw">YouTube Video 2</a></li>
                            </ul>
                        </li>
                        <li>
                            <strong>Kruskal's algorithm:</strong> Kruskal's algorithm is a greedy algorithm for finding the minimum spanning tree of a connected weighted graph. Kruskal's algorithm works by iteratively adding edges to the minimum spanning tree, starting with the edge with the lowest weight.
                            <ul>
                                <li><a href="https://www.gatevidyalay.com/kruskals-algorithm-kruskals-algorithm-example/">GateVidyalay</a></li>
                                <li><a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">GeeksforGeeks</a></li>
                                <li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/kruskal-algorithm">Simplilearn</a></li>
                                <li><a href="https://youtu.be/huQojf2tevI?si=meGTx1URpYH5XTNc">YouTube Video 1</a></li>
                                <li><a href="https://youtu.be/DMnDM_sxVig?si=b98GmU9PlYNh5Sb0">YouTube Video 2</a></li>
                            </ul>
                        </li>
                        <li>
                            <strong>Floyd-Warshall algorithm:</strong> The Floyd Warshall Algorithm is for solving all pairs of shortest-path problems. The problem is to find the shortest distances between every pair of vertices in a given edge-weighted directed Graph. This algorithm follows the dynamic programming approach to find the shortest path.
                            <ul>
                                <li><a href="https://youtu.be/wjv-w6q4ip4?si=1aR7gR13W62paseG">YouTube Video 1</a></li>
                                <li><a href="https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/">GeeksforGeeks</a></li>
                                <li><a href="https://www.programiz.com/dsa/floyd-warshall-algorithm">Programiz</a></li>
                                <li><a href="https://practice.geeksforgeeks.org/problems/implementing-floyd-warshall2042/1">GeeksforGeeks Practice</a></li>
                            </ul>
                        </li>
                    
                        
                            <li>
                                <strong>Huffman coding:</strong> Huffman coding is a lossless data compression algorithm. The idea is to assign variable-length codes to input characters, lengths of the assigned codes are based on the frequencies of corresponding characters.
                                <ul>
                                    <li><a href="https://www.youtube.com/watch?v=co4_ahEDCho&t=2s">YouTube Video 1</a></li>
                                    <li><a href="https://www.youtube.com/watch?v=0kNXhFIEd_w">YouTube Video 2</a></li>
                                    <li><a href="https://www.youtube.com/watch?v=saofdNsZiYY">YouTube Video 3</a></li>
                                    <li><a href="https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/">GeeksforGeeks</a></li>
                                    <li><a href="https://www.programiz.com/dsa/huffman-coding">Programiz</a></li>
                                </ul>
                            </li>
                            <li>
                                <strong>Activity selection problem:</strong> The activity selection problem is a combinatorial optimization problem. Given a set of activities with their start and finish times, the goal is to find a maximum-sized subset of activities that can be scheduled without conflicting with each other.
                                <ul>
                                    <li><a href="https://www.youtube.com/watch?v=DHr-Mn_vzs0">YouTube Video 1</a></li>
                                    <li><a href="https://www.youtube.com/watch?v=7UbMn9DlKxA">YouTube Video 2</a></li>
                                    <li><a href="https://youtu.be/poWB2UCuozA?si=yqNPztr6nbzUenXb">YouTube Video 3</a></li>
                                    <li><a href="https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/">GeeksforGeeks</a></li>
                                </ul>
                            </li>
                            <li>
                                <strong>Topological sort algorithms:</strong> Topological sort algorithms order the vertices of a directed acyclic graph (DAG) in a way such that all edges point from earlier vertices to later vertices in the ordering. Types: Kahn's algorithm, Tarjan's algorithm
                                <ul>
                                    <li><a href="https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/">GeeksforGeeks: Indegree-based solution</a></li>
                                    <li><a href="https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">GeeksforGeeks: Tarjan's algorithm</a></li>
                                    <li><a href="https://www.interviewkickstart.com/learn/kahns-algorithm-topological-sorting">InterviewKickstart: Kahn's algorithm</a></li>
                                    <li><a href="https://youtu.be/qrAub5z8FeA?si=utjArD8ffTZMUnjw">YouTube Video 1</a></li>
                                    <li><a href="https://youtu.be/73sneFXuTEg?si=eACqEfaUFV96Hxlf">YouTube Video 2</a></li>
                                </ul>
                            </li>
                            <li>
                                <strong>Sorting Algorithms:</strong> Sorting algorithms rearrange a given list of elements according to a comparison operator on the elements. Types: Insertion sort, selection sort, bubble sort, merge sort, quick sort, heap sort
                                <ul>
                                    <li><a href="https://youtu.be/HGk_ypEuS24?si=yy7Ry6mwp4f5QblU">YouTube Video 1</a></li>
                                    <li><a href="https://www.geeksforgeeks.org/introduction-to-sorting-algorithm/">GeeksforGeeks: Introduction</a></li>
                                    <li><a href="https://www.programiz.com/dsa/sorting-algorithm">Programiz</a></li>
                                </ul>
                            </li>
                            <li>
                                <strong>Hashing and Hash Tables: Two Sum Problem, Four Sum Problem, Subarray Sum Equals K, Longest Subarray with Sum K:</strong> Given an array of integers and a target sum, various problems can be solved using hashing and hash tables.
                                <ul>
                                    <li><a href="https://www.youtube.com/watch?v=W5q0xgxmRd8">YouTube Video 1</a></li>
                                    <li><a href="https://www.youtube.com/watch?v=zeMa9sg-VJM">YouTube Video 2</a></li>
                                    <li><a href="https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/">GeeksforGeeks: Introduction to Hashing</a></li>
                                    <li><a href="https://www.javatpoint.com/hash-table">JavaTpoint: Hash Table</a></li>
                                </ul>
                            </li>
                        
                            
                                <li>
                                    <strong>Priority Queue:</strong> A Priority Queue is a data structure in computer science that stores a collection of elements, each associated with a priority. Elements in a Priority Queue are typically ordered based on their priority, and elements with higher priorities are dequeued or processed before elements with lower priorities.
                                    <ul>
                                        <li><a href="https://www.youtube.com/watch?v=NlEwbC6Nt0c">YouTube Video 1</a></li>
                                        <li><a href="https://www.youtube.com/watch?v=HqPJF2L5h9U">YouTube Video 2</a></li>
                                        <li><a href="https://www.geeksforgeeks.org/priority-queue-set-1-introduction/">GeeksforGeeks</a></li>
                                        <li><a href="https://www.javatpoint.com/ds-priority-queue">JavaTpoint</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>AVL Tree (Adelson-Velsky and Landis Tree):</strong> An AVL tree is defined as a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees for any node cannot be more than one. The difference between the heights of the left subtree and the right subtree for any node is known as the balance factor of the node.
                                    <ul>
                                        <li><a href="https://www.youtube.com/watch?v=jDM6_TnYIqE">YouTube Video 1</a></li>
                                        <li><a href="https://www.youtube.com/watch?v=YWqla0UX-38">YouTube Video 2</a></li>
                                        <li><a href="https://www.geeksforgeeks.org/introduction-to-avl-tree/">GeeksforGeeks</a></li>
                                        <li><a href="https://www.javatpoint.com/avl-tree">JavaTpoint</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Segment Tree:</strong> This data structure can be used to solve a variety of problems on arrays, such as range queries and dynamic programming.
                                    <ul>
                                        <li><a href="https://www.youtube.com/watch?v=-dUiRtJ8ot0">YouTube Video 1</a></li>
                                        <li><a href="https://www.youtube.com/watch?v=rwXVCELcrqU">YouTube Video 2</a></li>
                                        <li><a href="https://www.geeksforgeeks.org/segment-tree-data-structure/">GeeksforGeeks</a></li>
                                        <li><a href="https://www.scaler.com/topics/data-structures/segment-trees-in-data-structure/">Scaler</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Fenwick Tree:</strong> This data structure can be used to solve a variety of problems on arrays, such as range queries and dynamic programming.
                                    <ul>
                                        <li><a href="https://www.youtube.com/watch?v=9uaXG62Y8Uw">YouTube Video 1</a></li>
                                        <li><a href="https://www.youtube.com/watch?v=nuUspQ7ORXE">YouTube Video 2</a></li>
                                        <li><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">GeeksforGeeks</a></li>
                                        <li><a href="https://www.javatpoint.com/fenwick-tree-in-java">JavaTpoint</a></li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Suffix Tree:</strong> A suffix tree for a given text is a compressed trie for all suffixes of the given text. Suffix trees are primarily employed for solving problems related to pattern matching, substring search, and other string-related tasks.
                                    <ul>
                                        <li><a href="https://www.youtube.com/watch?v=Yt0t_Diqp1o">YouTube Video 1</a></li>
                                        <li><a href="https://www.youtube.com/watch?v=N70NPX6xgsA">YouTube Video 2</a></li>
                                        <li><a href="https://www.geeksforgeeks.org/pattern-searching-using-suffix-tree/">GeeksforGeeks</a></li>
                                        <li><a href="https://www.hackerearth.com/practice/data-structures/advanced-data-structures/suffix-trees/tutorial/">HackerEarth</a></li>
                                    </ul>
                                </li>
                                                                
            
                                
                                    <li>
                                        <strong>Suffix Array:</strong> A suffix array is a sorted array of all suffixes of a given string. A suffix array can be constructed from Suffix tree by doing a DFS traversal of the suffix tree. In fact Suffix array and suffix tree both can be constructed from each other in linear time.
                                        <ul>
                                            <li><a href="https://www.geeksforgeeks.org/suffix-array-set-1-introduction/">GeeksforGeeks</a></li>
                                            <li><a href="https://www.hackerearth.com/practice/data-structures/advanced-data-structures/suffix-arrays/tutorial/">HackerEarth</a></li>
                                            <li><a href="https://www.scaler.com/topics/suffix-array/">Scaler</a></li>
                                            <li><a href="https://www.youtube.com/live/Lu5sByCfPvE?feature=shared">YouTube Live</a></li>
                                            <li><a href="https://cp-algorithms.com/string/suffix-array.html">CP Algorithms</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Matrix Chain Multiplication:</strong> This algorithm finds the most efficient way to multiply a chain of matrices. It is a classic dynamic programming problem that has many applications in computer science.
                                        <ul>
                                            <li><a href="https://www.youtube.com/watch?v=-UPo_dzBw1c&ab_channel=AnujBhaiya">YouTube Video 1</a></li>
                                            <li><a href="https://www.youtube.com/watch?v=_WncuhSJZyA&ab_channel=AbdulBari">YouTube Video 2</a></li>
                                            <li><a href="https://takeuforward.org/dynamic-programming/matrix-chain-multiplication-dp-48/">Take U Forward</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Maximum Independent Set:</strong> Given an undirected graph defined by the number of vertex V and the edges E[], the task is to find Maximal Independent Vertex Set in an undirected graph. Independent Set: An independent set in a graph is a set of vertices which are not directly connected to each other. Note: It is a given that there is at least one way to traverse from any vertex in the graph to another, i.e. the graph has one connected component.
                                        <ul>
                                            <li><a href="https://www.youtube.com/watch?v=H79WmvMMRdA">YouTube Video 1</a></li>
                                            <li><a href="https://www.youtube.com/watch?v=-LN5-GvV-bQ">YouTube Video 2</a></li>
                                            <li><a href="https://www.geeksforgeeks.org/maximal-independent-set-in-an-undirected-graph/">GeeksforGeeks</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Maximum Weight Clique:</strong> Given a small graph with N nodes and E edges, the task is to find the maximum clique in the given graph. A clique is a complete subgraph of a given graph. This means that all nodes in the said subgraph are directly connected to each other, or there is an edge between any two nodes in the subgraph. The maximal clique is the complete subgraph of a given graph which contains the maximum number of nodes.
                                        <ul>
                                            <li><a href="https://www.youtube.com/watch?v=WTzpaSxHAys">YouTube Video 1</a></li>
                                            <li><a href="https://www.youtube.com/watch?v=qZs767KQcvE">YouTube Video 2</a></li>
                                            <li><a href="https://www.geeksforgeeks.org/maximal-clique-problem-recursive-solution/">GeeksforGeeks</a></li>
                                        </ul>
                                    </li>
                                    <li>
                                        <strong>Job Sequencing:</strong> The job sequencing problem is a combinatorial optimization problem of finding the optimal order to sequence a set of jobs on a machine, such that the total time to complete all the jobs is minimized. The problem is NP-hard, which means that there is no known polynomial-time algorithm to solve it. However, there are a number of approximation algorithms that can be used to find good solutions to the problem in polynomial time.
                                        <ul>
                                            <li><a href="https://www.youtube.com/watch?v=LjPx4wQaRIs">YouTube Video 1</a></li>
                                            <li><a href="https://www.youtube.com/watch?v=M7Fl_z7_J2k&t=3s">YouTube Video 2</a></li>
                                            <li><a href="https://www.youtube.com/watch?v=zPtI8q9gvX8">YouTube Video 3</a></li>
                                            <li><a href="https://www.geeksforgeeks.org/job-sequencing-problem/">GeeksforGeeks</a></li>
                                            <li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_job_sequencing_with_deadline.htm">TutorialsPoint</a></li>
                                        </ul>
                                    </li>
                                
                                    
    <li>
        <strong>N-Queens:</strong> The n-queens problem is a classic combinatorial optimization problem of placing n unattacking queens on an n×n chessboard such that none of the queens can capture another queen.
        <ul>
            <li><a href="https://www.youtube.com/watch?v=i05Ju7AftcM">YouTube Video 1</a></li>
            <li><a href="https://www.youtube.com/watch?v=bRs6E_SL2Tk">YouTube Video 2</a></li>
            <li><a href="https://www.youtube.com/watch?v=xFv_Hl4B83A">YouTube Video 3</a></li>
            <li><a href="https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/">GeeksforGeeks</a></li>
            <li><a href="https://www.javatpoint.com/n-queens-problems">JavaTpoint</a></li>
        </ul>
    </li>
    <li>
        <strong>Karatsuba Algorithm:</strong> The Karatsuba algorithm is a fast multiplication algorithm that can be used to multiply two numbers of any size.
        <ul>
            <li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_karatsuba.htm">TutorialsPoint</a></li>
            <li><a href="https://www.geeksforgeeks.org/karatsuba-algorithm-for-fast-multiplication-using-divide-and-conquer-algorithm/">GeeksforGeeks</a></li>
            <li><a href="https://youtu.be/7_opFwubodM?si=rqno-SJxXcXBB7gk">YouTube Video</a></li>
        </ul>
    </li>
    <li>
        <strong>Kosaraju's Algorithm:</strong> Kosaraju's algorithm is a widely used algorithm for finding strongly connected components (SCCs) in a directed graph. Strongly connected components are subgraphs within a directed graph in which every vertex is reachable from every other vertex.
        <ul>
            <li><a href="https://www.youtube.com/watch?v=R6uoSjZ2imo">YouTube Video 1</a></li>
            <li><a href="https://www.youtube.com/watch?v=V8qIqJxCioo">YouTube Video 2</a></li>
            <li><a href="https://www.topcoder.com/thrive/articles/kosarajus-algorithm-for-strongly-connected-components">TopCoder</a></li>
        </ul>
    </li>
    <li>
        <strong>Tarjan's Algorithm:</strong> This algorithm finds the strongly connected components of a graph.
        <ul>
            <li><a href="https://www.youtube.com/watch?v=qrAub5z8FeA">YouTube Video 1</a></li>
            <li><a href="https://www.youtube.com/watch?v=wUgWX0nc4NY">YouTube Video 2</a></li>
            <li><a href="https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">GeeksforGeeks</a></li>
            <li><a href="https://www.topcoder.com/thrive/articles/tarjans-algorithm-for-strongly-connected-components">TopCoder</a></li>
        </ul>
    </li>
    <li>
        <strong>Flood Fill Algorithm:</strong> Given a 2D screen arr[][] where each arr[i][j] is an integer representing the color of that pixel, also given the location of a pixel (X, Y) and a color C, the task is to replace the color of the given pixel and all the adjacent same-colored pixels with the given color.
        <ul>
            <li><a href="https://www.youtube.com/watch?v=C-2_uSRli8o">YouTube Video 1</a></li>
            <li><a href="https://www.youtube.com/watch?v=zWqxSvkn9qk">YouTube Video 2</a></li>
            <li><a href="https://www.youtube.com/watch?v=RwozX--B_Xs">YouTube Video 3</a></li>
            <li><a href="https://www.geeksforgeeks.org/flood-fill-algorithm/">GeeksforGeeks</a></li>
            <li><a href="https://www.javatpoint.com/computer-graphics-flood-fill-algorithm">JavaTpoint</a></li>
        </ul>
    </li>


    
        <li>
            <strong>Hamiltonian Circuit Problem:</strong> The Hamiltonian Circuit problem is a decision problem in graph theory that asks whether there exists a Hamiltonian circuit in a given graph. A Hamiltonian circuit is a cycle that visits each vertex in the graph exactly once.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=dQr4wZCiJJ4">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=GiClUAJMMtw">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/hamiltonian-cycle/">GeeksforGeeks</a></li>
                <li><a href="https://www.javatpoint.com/hamiltonian-circuit-problems">JavaTpoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Aho-Corasick Algorithm:</strong> The Aho-Corasick algorithm is a string searching algorithm that efficiently finds all occurrences of multiple keywords (also known as "patterns") in a given input text.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=O7_w001f58c">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=qPyhPXPl3T4">YouTube Video 2</a></li>
                <li><a href="https://www.youtube.com/watch?v=vpH5gSSapjI">YouTube Video 3</a></li>
                <li><a href="https://www.geeksforgeeks.org/aho-corasick-algorithm-pattern-searching/">GeeksforGeeks</a></li>
                <li><a href="https://cp-algorithms.com/string/aho_corasick.html">CP-Algorithms</a></li>
            </ul>
        </li>
        <li>
            <strong>Knuth-Morris-Pratt Algorithm:</strong> This algorithm searches for a single pattern in a text string.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=V5-7GzOfADQ">YouTube Video 1</a></li>
                <li><a href="https://youtube.com/watch?v=ziteu2FpYsA">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/">GeeksforGeeks</a></li>
                <li><a href="https://www.javatpoint.com/daa-knuth-morris-pratt-algorithm">JavaTpoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Boyer Moore Algorithm:</strong> Pattern searching is an important problem in computer science. When we do search for a string in a notepad/word file, browser, or database, pattern searching algorithms are used to show the search results.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=hXqRLILcC1k">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=ZpR7DnwzgTE">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/boyer-moore-algorithm-for-pattern-searching/">GeeksforGeeks</a></li>
                <li><a href="https://www.tutorialspoint.com/Boyer-Moore-Algorithm">TutorialsPoint</a></li>
            </ul>
        </li>
        <li>
            <strong>Krauss Wildcard Matching Algorithm:</strong> Given a text and a wildcard pattern, implement a wildcard pattern matching algorithm that finds if the wildcard pattern is matched with text. The matching should cover the entire text (not partial text). The wildcard pattern can include the characters ‘?’ and ‘*’.
            <ul>
                <li><a href="https://www.youtube.com/watch?v=ZmlQ3vgAOMo&t=9s">YouTube Video 1</a></li>
                <li><a href="https://www.youtube.com/watch?v=OgovJ9CB0hI">YouTube Video 2</a></li>
                <li><a href="https://www.geeksforgeeks.org/wildcard-pattern-matching/">GeeksforGeeks</a></li>
            </ul>
        </li>
    </ol>
    </div>
                                
    
